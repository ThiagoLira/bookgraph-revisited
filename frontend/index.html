<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>BookGraph Explorer</title>
  <style>
    :root {
      --bg: #050505;
      /* Pure Dark */
      --panel: rgba(20, 20, 20, 0.8);
      --text: #ededed;
      --text-muted: #888;
      --accent: #00f2ff;

      /* Node Colors */
      --book-source: #ff4444;
      /* Red */
      --book-cited: #4444ff;
      /* Blue */
      --author: #999999;
      /* Gray */

      --edge: #404040;
      --edge-highlight: #ffffff;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Outfit", "Inter", sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 24px;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0));
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 10;
      pointer-events: none;
    }

    header>* {
      pointer-events: auto;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: linear-gradient(90deg, #fff, #94a3b8);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .search-box {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
      width: 240px;
      transition: all 0.2s;
    }

    .search-box:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(255, 255, 255, 0.1);
    }

    #info-panel {
      position: absolute;
      top: 80px;
      right: 24px;
      width: 320px;
      background: var(--panel);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transform: translateX(120%);
      transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      z-index: 5;
    }

    #info-panel.visible {
      transform: translateX(0);
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 16px;
    }

    .panel-title {
      font-size: 18px;
      font-weight: 600;
      line-height: 1.3;
      margin: 0;
    }

    .panel-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
    }

    .panel-close:hover {
      color: var(--text);
    }

    .meta-item {
      margin-bottom: 12px;
    }

    .meta-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .meta-value {
      font-size: 14px;
      line-height: 1.5;
    }

    .tag {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      margin-right: 6px;
      background: rgba(255, 255, 255, 0.1);
    }

    .tag.source {
      background: rgba(255, 68, 68, 0.2);
      color: var(--book-source);
    }

    .tag.cited {
      background: rgba(68, 68, 255, 0.2);
      color: var(--book-cited);
    }

    .tag.author {
      background: rgba(153, 153, 153, 0.2);
      color: var(--author);
    }

    svg {
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: grab;
    }

    svg:active {
      cursor: grabbing;
    }

    .link {
      stroke: var(--edge);
      stroke-opacity: 0;
      /* Hidden by default */
      transition: stroke 0.2s, stroke-opacity 0.2s;
      pointer-events: none;
    }

    .link.highlight {
      stroke: var(--edge-highlight);
      stroke-opacity: 0.6;
      stroke-width: 1.5px;
    }

    .node {
      transition: fill 0.2s, r 0.2s, opacity 0.2s;
      filter: drop-shadow(0 0 3px currentColor);
      cursor: pointer;
    }

    .node:hover {
      stroke: #fff;
      stroke-width: 2px;
    }

    .node.dimmed {
      opacity: 0.1;
    }

    .node.highlight {
      opacity: 1;
      stroke: #fff;
      stroke-width: 2px;
    }

    .label {
      font-size: 10px;
      fill: var(--text);
      pointer-events: none;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      opacity: 0;
      /* Hidden by default */
      transition: opacity 0.2s;
    }

    .label.visible {
      opacity: 1;
    }

    #loading {
      position: absolute;
      bottom: 24px;
      left: 24px;
      color: var(--text-muted);
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .spinner {
      width: 12px;
      height: 12px;
      border: 2px solid var(--text-muted);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@500;600&display=swap"
    rel="stylesheet">
</head>

<body>
  <header>
    <h1>BookGraph</h1>
    <div id="controls">
      <input type="text" class="search-box" placeholder="Search books or authors..." id="search">
    </div>
  </header>

  <div id="info-panel">
    <div class="panel-header">
      <h2 class="panel-title" id="panel-title">Title</h2>
      <button class="panel-close" id="panel-close">âœ•</button>
    </div>
    <div id="panel-content"></div>
  </div>

  <div id="loading">
    <div class="spinner"></div>
    <span id="status-text">Initializing...</span>
  </div>

  <svg>
    <defs>
      <marker id="arrow" viewBox="0 -5 10 10" refX="20" refY="0" markerWidth="4" markerHeight="4" orient="auto">
        <path d="M0,-3L8,0L0,3" fill="#404040" opacity="0.8"></path>
      </marker>
    </defs>
  </svg>

  <script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const width = window.innerWidth;
    const height = window.innerHeight;
    const svg = d3.select("svg");

    // Config
    const COLORS = {
      source: "#ff4444", // Red
      cited: "#4444ff", // Blue
      author: "#999999" // Gray
    };

    // State
    let graphData = { nodes: [], links: [] };
    let simulation;
    let transform = d3.zoomIdentity;
    let selectedNode = null;

    // Elements
    const g = svg.append("g");
    const linkGroup = g.append("g").attr("class", "links");
    const nodeGroup = g.append("g").attr("class", "nodes");
    const labelGroup = g.append("g").attr("class", "labels");

    const statusText = document.getElementById("status-text");
    const loadingEl = document.getElementById("loading");
    const panel = document.getElementById("info-panel");
    const searchInput = document.getElementById("search");

    // Zoom
    const zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on("zoom", e => {
        transform = e.transform;
        g.attr("transform", transform);
      });
    svg.call(zoom);

    // Background Click to Reset
    svg.on("click", (e) => {
      if (e.target.tagName === 'svg') {
        resetHighlight();
      }
    });

    // Data Loading
    async function loadData() {
      const params = new URLSearchParams(window.location.search);
      // Default to ./data for static hosting compatibility
      const dataDir = params.get("dataDir") || "./data";

      statusText.textContent = "Loading library manifest...";

      try {
        // Fetch manifest.json
        const manifestRes = await fetch(`${dataDir}/manifest.json`);
        if (!manifestRes.ok) throw new Error("Could not load manifest.json");
        const files = await manifestRes.json();

        statusText.textContent = `Loading ${files.length} books...`;

        const rawData = await Promise.all(files.map(async f => {
          const r = await fetch(`${dataDir}/${f}`);
          return r.json();
        }));

        processData(rawData);
        loadingEl.style.display = "none";
      } catch (e) {
        statusText.textContent = "Error: " + e.message;
        console.error(e);
      }
    }

    function processData(records) {
      const authorMap = new Map();
      const bookMap = new Map(); // Global book registry for linking
      const links = [];

      // Helper to get/create author
      function getAuthor(id, name, meta = {}) {
        if (!authorMap.has(id)) {
          authorMap.set(id, {
            id,
            type: 'author',
            label: name,
            books: [],
            meta: meta,
            r: 25, // Base radius
            x: width / 2 + (Math.random() - 0.5) * 50,
            y: height / 2 + (Math.random() - 0.5) * 50
          });
        } else {
          // Merge metadata
          const existing = authorMap.get(id);
          existing.meta = { ...existing.meta, ...meta };
        }
        return authorMap.get(id);
      }

      // Pass 1: Register all Source Books & Authors first
      records.forEach(rec => {
        const src = rec.source;
        // Iterate over NAMES, not IDs, because IDs might be empty
        const authors = src.authors || ["Unknown"];
        const ids = src.author_ids || [];

        authors.forEach((name, i) => {
          // Use ID if available, otherwise generate from name
          const aid = ids[i] ? `author:${ids[i]}` : `author:name:${name.replace(/\s+/g, '_')}`;
          const author = getAuthor(aid, name);

          const bookId = `book:${src.goodreads_id}`;
          if (!bookMap.has(bookId)) {
            const book = {
              id: bookId,
              type: 'book',
              label: src.title,
              root: true,
              meta: src,
              r: 4,
              parent: author
            };
            bookMap.set(bookId, book);
            author.books.push(book);
          }
        });
      });

      // Pass 2: Process Citations & Link
      records.forEach(rec => {
        const src = rec.source;
        const srcBookId = `book:${src.goodreads_id}`;

        (rec.citations || []).forEach(cit => {
          const match = cit.goodreads_match || {};
          const edge = cit.edge || {};
          if (edge.target_type === 'not_found') return;

          // Target Book
          let targetBookId = null;
          if (edge.target_book_id) {
            targetBookId = `book:${edge.target_book_id}`;
          }

          // Target Authors
          (edge.target_author_ids || []).forEach((aid, i) => {
            // Resolve Name
            let name = "Unknown";
            if (match.authors && match.author_ids) {
              const idx = match.author_ids.indexOf(aid);
              if (idx >= 0 && match.authors[idx]) name = match.authors[idx];
            }
            if (name === "Unknown") name = match.author || match.name || "Unknown";

            // Extract Author Metadata
            let authorMeta = {};
            if (match.works_count !== undefined || match.fans_count !== undefined) {
              authorMeta = match;
            }

            const author = getAuthor(`author:${aid}`, name, authorMeta);

            // If we have a target book, add it to this author
            if (targetBookId) {
              // Only add if NOT already in map (avoid overwriting source book if it exists)
              if (!bookMap.has(targetBookId)) {
                const book = {
                  id: targetBookId,
                  type: 'book',
                  label: match.title,
                  root: false,
                  meta: match,
                  r: 4,
                  parent: author
                };
                bookMap.set(targetBookId, book);
                author.books.push(book);
              }
            }

            // ALWAYS link Source Book -> Cited Author
            // This ensures co-authors (who don't hold the book node) are still connected
            if (bookMap.has(srcBookId)) {
              links.push({
                source: bookMap.get(srcBookId),
                target: author,
                type: 'citation'
              });
            }
          });

          // Wikipedia Person
          if (edge.target_person) {
            const person = edge.target_person;
            const pid = `person:${person.page_id}`;
            getAuthor(pid, person.title, person);
          }

          // Create Citation Links (Book -> Book)
          if (bookMap.has(srcBookId) && targetBookId && bookMap.has(targetBookId)) {
            links.push({
              source: bookMap.get(srcBookId),
              target: bookMap.get(targetBookId),
              type: 'citation'
            });
          }

          // Link Source Book -> Wikipedia Person
          if (bookMap.has(srcBookId) && edge.target_person) {
            const pid = `person:${edge.target_person.page_id}`;
            if (authorMap.has(pid)) {
              links.push({
                source: bookMap.get(srcBookId),
                target: authorMap.get(pid),
                type: 'citation'
              });
            }
          }
        });
      });

      // Calculate Author Radii based on book count
      authorMap.forEach(a => {
        a.r = 20 + (a.books.length * 3);
      });

      // Prepare Physics Data
      // Only Authors are in the simulation
      const physicsNodes = Array.from(authorMap.values());

      // We need "physics links" to keep related authors together.
      // If Book A (in Author X) cites Book B (in Author Y), we add a force between X and Y.
      const physicsLinks = [];
      links.forEach(l => {
        const sourceAuthor = l.source.type === 'author' ? l.source : l.source.parent;
        const targetAuthor = l.target.type === 'author' ? l.target : l.target.parent;

        if (sourceAuthor && targetAuthor && sourceAuthor !== targetAuthor) {
          physicsLinks.push({
            source: sourceAuthor.id,
            target: targetAuthor.id
          });
        }
      });

      graphData = {
        nodes: physicsNodes, // For simulation
        allBooks: Array.from(bookMap.values()), // For rendering
        links: links, // Visual links (Book -> Book)
        physicsLinks: physicsLinks // Invisible links for force layout
      };

      initSimulation();
    }

    function initSimulation() {
      console.log(`Initialized simulation with ${graphData.nodes.length} authors, ${graphData.allBooks.length} books, and ${graphData.links.length} links.`);

      simulation = d3.forceSimulation(graphData.nodes)
        .force("link", d3.forceLink(graphData.physicsLinks).id(d => d.id).distance(30).strength(0.5))
        .force("charge", d3.forceManyBody().strength(-30))
        .force("center", d3.forceCenter(width / 2, height / 2).strength(1))
        .force("collide", d3.forceCollide().radius(d => d.r + 5).iterations(2))
        .alphaDecay(0.05)
        .on("tick", ticked);

      // Pre-warm the simulation to avoid initial wild movement
      console.log("Pre-warming simulation...");
      simulation.tick(300);
      console.log("Simulation pre-warmed.");

      render();
    }

    function ticked() {
      // 1. Update Author Positions (handled by sim)

      // 2. Update Book Positions (relative to parent Author)
      graphData.nodes.forEach(author => {
        const books = author.books;
        if (!books.length) return;

        // Place books in a circle/spiral inside the author
        const step = (Math.PI * 2) / books.length;
        const radius = author.r * 0.6; // Keep inside

        books.forEach((book, i) => {
          book.x = author.x + Math.cos(i * step) * radius;
          book.y = author.y + Math.sin(i * step) * radius;
        });
      });

      // 3. Update Visuals
      nodeGroup.selectAll(".author-node")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      nodeGroup.selectAll(".book-node")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      linkGroup.selectAll("line")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      labelGroup.selectAll("text")
        .attr("x", d => d.x)
        .attr("y", d => d.y);
    }

    function render() {
      // Links
      const link = linkGroup.selectAll("line")
        .data(graphData.links)
        .join("line")
        .attr("class", "link")
        .attr("stroke-width", 1)
        .attr("marker-end", "url(#arrow)");

      // Author Nodes
      const authors = nodeGroup.selectAll(".author-node")
        .data(graphData.nodes)
        .join("circle")
        .attr("class", "node author-node")
        .attr("r", d => d.r)
        .attr("fill", COLORS.author)
        .attr("opacity", 0.5) // Slightly visible by default
        .attr("stroke", COLORS.author)
        .attr("stroke-width", 1)
        .on("click", (e, d) => { e.stopPropagation(); highlightNode(d); });

      // Book Nodes
      const books = nodeGroup.selectAll(".book-node")
        .data(graphData.allBooks)
        .join("circle")
        .attr("class", "node book-node")
        .attr("r", 4)
        .attr("fill", d => d.root ? COLORS.source : COLORS.cited)
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .on("click", (e, d) => { e.stopPropagation(); highlightNode(d); });

      // Labels (Author Names)
      const labels = labelGroup.selectAll("text")
        .data(graphData.nodes)
        .join("text")
        .attr("class", "label")
        .text(d => d.label)
        .attr("text-anchor", "middle")
        .attr("dy", d => -d.r - 5) // Above the circle
        .style("font-size", "12px")
        .style("fill", "#fff")
        .style("pointer-events", "none");
    }

    function highlightNode(d) {
      selectedNode = d;
      showPanel(d);

      // 1. Find neighbors
      const neighbors = new Set();
      neighbors.add(d.id);

      // Find connected links
      const connectedLinks = graphData.links.filter(l => l.source.id === d.id || l.target.id === d.id);
      connectedLinks.forEach(l => {
        neighbors.add(l.source.id);
        neighbors.add(l.target.id);
      });

      // 2. Update Visuals
      // Nodes
      nodeGroup.selectAll("circle")
        .classed("dimmed", n => !neighbors.has(n.id))
        .classed("highlight", n => neighbors.has(n.id));

      // Links
      linkGroup.selectAll("line")
        .classed("highlight", l => l.source.id === d.id || l.target.id === d.id)
        .style("stroke-opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0);

      // Labels
      labelGroup.selectAll("text")
        .classed("visible", n => neighbors.has(n.id));
    }

    function resetHighlight() {
      selectedNode = null;
      panel.classList.remove("visible");

      // Reset Nodes
      nodeGroup.selectAll("circle")
        .classed("dimmed", false)
        .classed("highlight", false);

      // Reset Links (Hide all)
      linkGroup.selectAll("line")
        .classed("highlight", false)
        .style("stroke-opacity", 0);

      // Reset Labels (Hide all)
      labelGroup.selectAll("text")
        .classed("visible", false);
    }

    // UI Logic
    function showPanel(d) {
      const meta = d.meta || {};
      document.getElementById("panel-title").textContent = d.label;

      const content = document.getElementById("panel-content");
      content.innerHTML = "";

      const fields = [
        { label: "Type", value: d.type === 'book' ? (d.root ? "Source Book" : "Cited Book") : "Author", tag: true },
        { label: "Books Count", value: d.type === 'author' ? d.books.length : null },
        { label: "Works Count", value: meta.works_count },
        { label: "Fans Count", value: meta.fans_count },
        { label: "Categories", value: meta.categories?.join(", ") },
        { label: "Authors", value: meta.authors?.join(", ") },
        { label: "Year", value: meta.publication_year },
        { label: "Rating", value: meta.average_rating },
        { label: "Description", value: meta.description },
        { label: "Goodreads ID", value: meta.goodreads_id || meta.id }
      ];

      fields.forEach(f => {
        if (!f.value) return;
        const div = document.createElement("div");
        div.className = "meta-item";

        const label = document.createElement("div");
        label.className = "meta-label";
        label.textContent = f.label;

        const val = document.createElement("div");
        val.className = "meta-value";

        if (f.tag) {
          const span = document.createElement("span");
          span.className = `tag ${d.type} ${d.root ? 'source' : 'cited'}`;
          span.textContent = f.value;
          val.appendChild(span);
        } else {
          val.textContent = f.value;
        }

        div.appendChild(label);
        div.appendChild(val);
        content.appendChild(div);
      });

      panel.classList.add("visible");
    }

    document.getElementById("panel-close").onclick = () => {
      resetHighlight();
    };

    // Search
    searchInput.addEventListener("input", (e) => {
      const term = e.target.value.toLowerCase();
      if (!term) {
        resetHighlight();
        return;
      }

      // Find first match
      const match = graphData.nodes.find(n => n.label.toLowerCase().includes(term)) ||
        graphData.allBooks.find(b => b.label.toLowerCase().includes(term));

      if (match) {
        highlightNode(match);
        // Center view on match (optional, but good for UX)
        const scale = 1.5;
        const x = -match.x * scale + width / 2;
        const y = -match.y * scale + height / 2;
        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity.translate(x, y).scale(scale)
        );
      }
    });

    // Start
    loadData();
  </script>
</body>

</html>