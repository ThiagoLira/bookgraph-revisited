<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Citation Graph Viewer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-yWak7E+zmX1W6IMlYQDD3Juk50M4VUsdxOjv+R1GgiRnyXFoGnSAGFF4ON87NV6BBuPpJw3lOZKHWWUAofsmMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    :root {
      --bg: #0b1021;
      --panel: #121933;
      --text: #e6ecff;
      --muted: #9fb0d9;
      --book: #64d8cb;
      --author: #f7a46c;
      --edge: #4b5d8c;
      --accent: #7ce5ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(124,229,255,0.12), transparent 35%), var(--bg);
      color: var(--text);
      overflow: hidden;
    }
    header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(11,16,33,0.9), rgba(11,16,33,0.3));
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 2;
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(124,229,255,0.15);
    }
    #title { font-weight: 700; letter-spacing: 0.3px; }
    #status { color: var(--muted); font-size: 14px; }
    #legend { margin-left: auto; display: flex; align-items: center; gap: 12px; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }
    .swatch { width: 10px; height: 10px; border-radius: 50%; }
    .pill input { margin: 0; cursor: pointer; }
    svg { width: 100vw; height: 100vh; display: block; }
    .node { stroke: #0b1021; stroke-width: 1px; cursor: pointer; }
    .node.book { fill: var(--book); }
    .node.author { fill: var(--author); }
    .link { stroke: var(--edge); stroke-opacity: 0.5; }
    .label { fill: var(--text); font-size: 11px; pointer-events: none; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    .highlight { stroke: var(--accent); stroke-width: 2.2px; stroke-opacity: 0.9; }
  </style>
</head>
<body>
  <header>
    <div id="title">Citation Graph Viewer</div>
    <div id="status">Loading…</div>
    <div id="legend">
      <label class="pill"><input id="toggle-books" type="checkbox" checked /><span class="swatch" style="background: var(--book)"></span>Books</label>
      <label class="pill"><input id="toggle-authors" type="checkbox" checked /><span class="swatch" style="background: var(--author)"></span>Authors</label>
    </div>
  </header>
  <svg></svg>

  <script>
    const params = new URLSearchParams(window.location.search);
    const dataDir = params.get("dataDir") || "calibre_outputs/calibre_bookgraph/final_citations_metadata_goodreads";

    const statusEl = document.getElementById("status");
    const toggleBooks = document.getElementById("toggle-books");
    const toggleAuthors = document.getElementById("toggle-authors");

    function setStatus(msg) { statusEl.textContent = msg; }

    async function listJsonFiles(dir) {
      // Assumes directory listing is available (e.g., python -m http.server)
      const res = await fetch(dir + "/");
      if (!res.ok) throw new Error(`Failed to list ${dir}: ${res.status}`);
      const html = await res.text();
      const matches = [...html.matchAll(/href=["']([^"']+\.json)["']/gi)];
      return matches.map(m => decodeURIComponent(m[1])).filter(f => !f.includes("/"));
    }

    async function loadAll() {
      setStatus(`Listing ${dataDir}…`);
      const files = await listJsonFiles(dataDir);
      setStatus(`Loading ${files.length} files…`);
      const data = await Promise.all(files.map(async f => {
        const res = await fetch(`${dataDir}/${f}`);
        if (!res.ok) throw new Error(`Failed to fetch ${f}: ${res.status}`);
        return res.json();
      }));
      return data;
    }

    function buildGraph(records) {
      const nodes = new Map(); // id -> node
      const links = [];
      const addNode = (id, type, label, meta = {}) => {
        if (!id) return;
        if (!nodes.has(id)) nodes.set(id, { id, type, label, meta });
      };
      const addLink = (source, target) => {
        if (!source || !target) return;
        const key = `${source}|${target}`;
        if (linkSet.has(key)) return;
        linkSet.add(key);
        links.push({ source, target });
      };
      const linkSet = new Set();

      for (const rec of records) {
        const src = rec.source || {};
        const srcBookId = src.goodreads_id || (src.goodreads && src.goodreads.book_id);
        addNode(`book:${srcBookId}`, "book", src.title || `Book ${srcBookId}`, src);

        for (const cit of rec.citations || []) {
          const edge = cit.edge || {};
          const tgtBook = edge.target_book_id;
          const tgtAuthors = edge.target_author_ids || [];

          if (tgtBook) {
            addNode(`book:${tgtBook}`, "book", cit.goodreads_match?.title || tgtBook, cit.goodreads_match || {});
            addLink(`book:${srcBookId}`, `book:${tgtBook}`);
          }
          for (const aid of tgtAuthors) {
            addNode(`author:${aid}`, "author", cit.goodreads_match?.author || cit.goodreads_match?.name || aid, cit.goodreads_match || {});
            addLink(`book:${srcBookId}`, `author:${aid}`);
          }
        }
      }
      return { nodes: Array.from(nodes.values()), links };
    }

    function render(graph) {
      const svg = d3.select("svg");
      svg.selectAll("*").remove();
      const width = window.innerWidth;
      const height = window.innerHeight;

      const g = svg.append("g");
      const zoom = d3.zoom().scaleExtent([0.1, 5]).on("zoom", (event) => {
        g.attr("transform", event.transform);
      });
      svg.call(zoom);

      const link = g.append("g")
        .attr("stroke-width", 1.2)
        .selectAll("line")
        .data(graph.links)
        .enter().append("line")
        .attr("class", "link");

      const node = g.append("g")
        .selectAll("circle")
        .data(graph.nodes)
        .enter().append("circle")
        .attr("class", d => `node ${d.type}`)
        .attr("r", d => d.type === "book" ? 8 : 6)
        .call(d3.drag()
          .on("start", (event, d) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
          })
          .on("drag", (event, d) => {
            d.fx = event.x; d.fy = event.y;
          })
          .on("end", (event, d) => {
            if (!event.active) simulation.alphaTarget(0);
            // Click toggles pin; drag end leaves pinned unless clicked again
          })
        )
        .on("click", (event, d) => {
          d.fx = d.fx == null ? d.x : null;
          d.fy = d.fy == null ? d.y : null;
        })
        .on("mouseover", function(event, d) {
          node.classed("highlight", n => n === d || neighbors.has(`${d.id}|${n.id}`) || neighbors.has(`${n.id}|${d.id}`));
          link.classed("highlight", l => l.source.id === d.id || l.target.id === d.id);
        })
        .on("mouseout", () => {
          node.classed("highlight", false);
          link.classed("highlight", false);
        });

      const label = g.append("g")
        .selectAll("text")
        .data(graph.nodes)
        .enter().append("text")
        .attr("class", "label")
        .attr("dx", 10)
        .attr("dy", 4)
        .text(d => d.label);

      const neighbors = new Set(graph.links.map(l => `${l.source.id || l.source}|${l.target.id || l.target}`));

      const simulation = d3.forceSimulation(graph.nodes)
        .force("link", d3.forceLink(graph.links).id(d => d.id).distance(d => d.type === "book" ? 80 : 60).strength(0.15))
        .force("charge", d3.forceManyBody().strength(-160))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => d.type === "book" ? 14 : 10));

      simulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
        label
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });

      const updateVisibility = () => {
        node.style("display", d => (d.type === "book" && !toggleBooks.checked) || (d.type === "author" && !toggleAuthors.checked) ? "none" : null);
        label.style("display", d => (d.type === "book" && !toggleBooks.checked) || (d.type === "author" && !toggleAuthors.checked) ? "none" : null);
        const hidden = new Set(graph.nodes.filter(d => ((d.type === "book" && !toggleBooks.checked) || (d.type === "author" && !toggleAuthors.checked))).map(d => d.id));
        link.style("display", l => hidden.has(l.source.id) || hidden.has(l.target.id) ? "none" : null);
      };
      toggleBooks.onchange = updateVisibility;
      toggleAuthors.onchange = updateVisibility;
      updateVisibility();
    }

    loadAll()
      .then(records => {
        const graph = buildGraph(records);
        setStatus(`Loaded ${graph.nodes.length} nodes, ${graph.links.length} edges`);
        render(graph);
      })
      .catch(err => {
        console.error(err);
        setStatus(err.message || "Failed to load data");
      });
  </script>
</body>
</html>
