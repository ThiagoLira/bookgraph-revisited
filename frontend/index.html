<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>BookGraph Explorer</title>
  <style>
    :root {
      --bg: #050505;
      --panel: rgba(20, 20, 20, 0.9);
      --text: #ededed;
      --text-muted: #888;
      --accent: #00f2ff;

      /* Node Colors */
      --book-source: #ff4444;
      --book-cited: #4444ff;
      --author-fill: rgba(255, 255, 255, 0.05);
      --author-stroke: rgba(255, 255, 255, 0.2);

      --edge: #404040;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Outfit", "Inter", sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow-y: auto;
      /* Allow scrolling */
      overflow-x: hidden;
      touch-action: pan-y;
      /* Enforce vertical scrolling */
    }

    header {
      position: fixed;
      /* Fixed header */
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 24px;
      background: linear-gradient(180deg, rgba(5, 5, 5, 0.95), rgba(5, 5, 5, 0));
      display: flex;
      justify-content: space-between;
      z-index: 10;
      pointer-events: none;
    }

    header>* {
      pointer-events: auto;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      background: linear-gradient(90deg, #fff, #94a3b8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #controls {
      display: flex;
      gap: 12px;
    }

    .search-box {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text);
      width: 240px;
    }

    .search-box:focus {
      outline: none;
      border-color: var(--accent);
    }

    #info-panel {
      position: fixed;
      top: 80px;
      right: 24px;
      width: 320px;
      background: var(--panel);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 20px;
      transform: translateX(120%);
      transition: transform 0.3s;
      z-index: 5;
    }

    #info-panel.visible {
      transform: translateX(0);
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .panel-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }

    .panel-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
    }

    svg {
      width: 100vw;
      /* Height set dynamically via JS */
      display: block;
    }

    .link {
      stroke: var(--edge);
      stroke-opacity: 0.3;
      /* Increased from 0.1 */
      stroke-width: 1px;
      fill: none;
      pointer-events: none;
    }

    .link.highlight {
      stroke: #fff;
      stroke-opacity: 0.8;
      stroke-width: 1.5px;
    }

    .link.dimmed {
      stroke-opacity: 0.05;
    }

    .axis text {
      font-size: 14px;
      fill: var(--text-muted);
      font-family: "Outfit", sans-serif;
    }

    .axis line,
    .axis path {
      stroke: var(--text-muted);
      stroke-opacity: 0.3;
    }

    .author-circle {
      fill: var(--author-fill);
      stroke: var(--author-stroke);
      stroke-width: 1px;
      transition: all 0.2s;
    }

    .author-group:hover .author-circle,
    .author-group.highlight .author-circle {
      stroke: var(--accent);
      stroke-width: 2px;
      fill: rgba(255, 255, 255, 0.1);
    }

    .book-circle {
      stroke: none;
      transition: r 0.2s;
      cursor: pointer;
    }

    .book-circle:hover {
      stroke: #fff;
      stroke-width: 2px;
    }

    .label {
      font-size: 14px;
      fill: #fff;
      pointer-events: none;
      text-anchor: middle;
      opacity: 0;
      /* Hidden by default */
      transition: opacity 0.2s;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9);
      font-weight: 500;
    }

    .label.visible {
      opacity: 1;
    }

    #loading {
      position: absolute;
      bottom: 24px;
      left: 24px;
      color: var(--text-muted);
      font-size: 13px;
    }
  </style>
</head>

<body>
  <header>
    <h1>BookGraph Vertical</h1>
    <div id="controls">
      <input type="text" class="search-box" placeholder="Search..." id="search">
    </div>
  </header>

  <div id="info-panel">
    <div class="panel-header">
      <h2 class="panel-title" id="panel-title">Title</h2>
      <button class="panel-close" id="panel-close">✕</button>
    </div>
    <div id="panel-content"></div>
  </div>

  <div id="loading">Initializing...</div>

  <svg>
    <g id="main-group"></g>
  </svg>

  <script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const width = window.innerWidth;
    const height = window.innerHeight;
    const svg = d3.select("svg");
    const g = d3.select("#main-group");

    // Layers
    const linkGroup = g.append("g").attr("class", "links");
    const nodeGroup = g.append("g").attr("class", "nodes");
    const labelGroup = g.append("g").attr("class", "labels");
    const axisGroup = g.append("g").attr("class", "axis");

    // State
    let pubDateMap = {};
    let authorMeta = {};
    let simulation;
    let graphData = { authors: [], links: [] };
    let selectedNode = null;

    // Clear selection on background click
    svg.on("click", () => {
      selectedNode = null;
      resetHighlight();
    });

    // Zoom removed for native scrolling
    // const zoom = d3.zoom() ...

    // Load Data
    async function loadData() {
      const params = new URLSearchParams(window.location.search);
      const dataDir = params.get("dataDir") || "./data";

      try {
        const [dates, authors, manifest] = await Promise.all([
          fetch(`${dataDir}/original_publication_dates.json`).then(r => r.json()),
          fetch(`${dataDir}/authors_metadata.json`).then(r => r.json()),
          fetch(`${dataDir}/manifest.json`).then(r => r.json())
        ]);

        pubDateMap = dates;
        authorMeta = authors;

        const files = await Promise.all(manifest.map(f => fetch(`${dataDir}/${f}`).then(r => r.json())));
        processData(files);

        document.getElementById("loading").style.display = "none";
      } catch (e) {
        console.error(e);
        document.getElementById("loading").textContent = "Error loading data";
      }
    }

    function parseYear(dateStr) {
      if (!dateStr) return null;
      if (typeof dateStr === 'number') return dateStr;
      if (dateStr.toString().includes("BC")) return -parseInt(dateStr.replace(/\D/g, ''));
      const d = new Date(dateStr);
      return !isNaN(d.getFullYear()) ? d.getFullYear() : null;
    }

    function getBookYear(meta) {
      const gid = meta.goodreads_id || (meta.goodreads_match ? meta.goodreads_match.book_id : null);
      if (gid && pubDateMap[gid]) return parseYear(pubDateMap[gid]);
      if (meta.publication_year) return meta.publication_year;
      return null;
    }

    function normalizeAuthor(name) {
      if (!name) return "Unknown";

      if (name.includes(",")) {
        const parts = name.split(",", 2);
        if (parts.length === 2) return `${parts[1].trim()} ${parts[0].trim()}`;
      }
      return name;
    }

    function processData(records) {
      const authorMap = new Map(); // name -> { name, books: [], year }
      const bookMap = new Map();   // id -> bookNode

      // 1. Collect all books and assign to authors
      records.forEach(rec => {
        // Source Book
        const src = rec.source;
        const srcAuth = normalizeAuthor(Array.isArray(src.authors) ? src.authors[0] : src.authors);
        const srcYear = getBookYear(src);

        if (!authorMap.has(srcAuth)) authorMap.set(srcAuth, { name: srcAuth, books: [], isSource: true });
        const srcAuthorNode = authorMap.get(srcAuth);

        const srcBook = {
          id: `book:${src.goodreads_id}`,
          title: src.title,
          year: srcYear,
          isSource: true,
          meta: src
        };
        srcAuthorNode.books.push(srcBook);
        bookMap.set(srcBook.id, srcBook);

        // Cited Books
        (rec.citations || []).forEach(cit => {
          const match = cit.goodreads_match || {};
          const wiki = cit.wikipedia_match || {};

          // If it's a book citation
          if (cit.edge && cit.edge.target_book_id) {
            const citedAuth = normalizeAuthor(match.authors ? match.authors[0] : "Unknown");
            const citedYear = getBookYear(match);

            if (!authorMap.has(citedAuth)) authorMap.set(citedAuth, { name: citedAuth, books: [] });
            const citedAuthorNode = authorMap.get(citedAuth);

            const citedBook = {
              id: `book:${cit.edge.target_book_id}`,
              title: match.title || "Unknown",
              year: citedYear,
              isSource: false,
              meta: match
            };

            // Avoid duplicates within author
            if (!citedAuthorNode.books.find(b => b.id === citedBook.id)) {
              citedAuthorNode.books.push(citedBook);
              bookMap.set(citedBook.id, citedBook);
            }
          }
          // If it's an author citation (no book), we create a "dummy" book or just track the author?
          // User asked for "Author balls containing book balls". 
          // If author has no books, we treat them as an empty author ball?
          else if (cit.edge && cit.edge.target_author_ids) {
            const name = wiki.title || (match.authors ? match.authors[0] : "Unknown");
            const normName = normalizeAuthor(name);
            if (!authorMap.has(normName)) authorMap.set(normName, { name: normName, books: [] });
          }
        });
      });

      // 2. Calculate Author Positions & Pack Books
      const authors = Array.from(authorMap.values()).map(auth => {
        // Calculate Year
        // Calculate Year
        let year = null;
        const meta = authorMeta[auth.name];

        // Priority 1: Author Metadata (Birth/Death)
        if (meta && meta.birth_year) {
          // Use midpoint of life, or birth + 30 if death unknown (active years)
          const endYear = meta.death_year || (meta.birth_year + 60);
          year = (meta.birth_year + endYear) / 2;
        }

        // Priority 2: Mean of Book Years (Fallback)
        if (year === null) {
          const validBookYears = auth.books.map(b => b.year).filter(y => y !== null);
          if (validBookYears.length > 0) {
            year = validBookYears.reduce((a, b) => a + b, 0) / validBookYears.length;
          }
        }

        // Pack Books
        // We create a hierarchy: Root -> Books
        const root = { children: auth.books.map(b => ({ ...b, value: 1 })) };
        const pack = d3.pack().padding(2);
        // Estimate radius based on book count to avoid huge empty circles
        // But d3.pack needs a size. We can run it with an arbitrary size and then scale?
        // Better: d3.packSiblings (if we just had circles) or d3.packEnclose.
        // Let's use d3.pack on a hierarchy.

        const hierarchy = d3.hierarchy(root).sum(d => d.value || 1);
        // Radius of book = 5 (source) or 3 (cited)
        hierarchy.children?.forEach(c => {
          c.r = c.data.isSource ? 8 : 4;
        });

        // We need to pack them. d3.pack() expects a size. 
        // Instead, let's use d3.packSiblings which packs circles tightly.
        const circles = (hierarchy.children || []).map(c => ({ r: c.r, data: c.data }));
        d3.packSiblings(circles);

        // Enclose them to get author radius
        const enclosure = d3.packEnclose(circles);
        const r = enclosure ? enclosure.r + 5 : (auth.isSource ? 10 : 5); // Padding

        return {
          id: `author:${auth.name}`,
          name: auth.name,
          year: year,
          r: r,
          books: circles, // {x, y, r, data} relative to center (0,0)
          x: width / 2, // Initial pos
          y: height / 2
        };
      });

      // Filter authors with no year? Or put them at "Unknown"?
      // User said "bottom to top". Let's put unknowns at the side or filter.
      // Let's keep them but put them at 2025 (top) or separate.
      const validAuthors = authors.filter(a => a.year !== null);

      // 3. Links (Author to Author)
      const authorNodeMap = new Map(validAuthors.map(a => [a.name, a]));
      const linkSet = new Set();
      const links = [];

      records.forEach(rec => {
        const src = rec.source;
        const srcName = normalizeAuthor(Array.isArray(src.authors) ? src.authors[0] : src.authors);
        const srcNode = authorNodeMap.get(srcName);

        if (!srcNode) return;

        (rec.citations || []).forEach(cit => {
          let targetName = null;
          const match = cit.goodreads_match || {};
          const wiki = cit.wikipedia_match || {};

          if (cit.edge && cit.edge.target_book_id) {
            targetName = normalizeAuthor(match.authors ? match.authors[0] : "Unknown");
          } else if (cit.edge && cit.edge.target_author_ids) {
            targetName = normalizeAuthor(wiki.title || (match.authors ? match.authors[0] : "Unknown"));
          }

          if (targetName) {
            const targetNode = authorNodeMap.get(targetName);
            if (targetNode && targetNode !== srcNode) {
              const key = `${srcName}|${targetName}`;
              if (!linkSet.has(key)) {
                linkSet.add(key);
                links.push({ source: srcNode, target: targetNode });
              }
            }
          }
        });
      });

      graphData.authors = validAuthors;
      graphData.links = links;
      initSimulation();
    }

    function initSimulation() {
      const authors = graphData.authors;

      // Y Scale: Ancient (Bottom) -> Modern (Top)
      // Y Scale: Ancient (Bottom) -> Modern (Top)
      const years = authors.map(a => a.year);
      const minYear = Math.min(...years);
      const maxYear = Math.max(...years);

      // Variable Resolution Configuration
      const splitYear = 1800; // Breakpoint between low and high density
      const lowRes = 0.3;     // Pixels per year for Ancient/Pre-1800 (Balanced)
      const highRes = 8;      // Pixels per year for Modern/Post-1800 (Balanced)

      // Calculate Distances
      const ancientSpan = Math.max(0, splitYear - minYear);
      const modernSpan = Math.max(0, maxYear - splitYear);

      const ancientHeight = ancientSpan * lowRes;
      const modernHeight = modernSpan * highRes;

      const totalHeight = ancientHeight + modernHeight + 400; // + Padding

      svg.attr("height", totalHeight);

      // Polylinear Scale
      // Domain: [Min, Split, Max]
      // Range: [Bottom, SplitPoint, Top]
      // Note: Y coords go Top(0) -> Bottom(Height). 
      // So MinYear is at TotalHeight (minus padding), MaxYear is at Top (plus padding).

      const yBottom = totalHeight - 100;
      const ySplit = yBottom - ancientHeight;
      const yTop = ySplit - modernHeight; // Should be approx 300

      const yScale = d3.scaleLinear()
        .domain([minYear, splitYear, maxYear])
        .range([yBottom, ySplit, yTop]);

      // Axis
      const yAxis = d3.axisRight(yScale)
        .tickValues([
          ...d3.range(Math.ceil(minYear / 100) * 100, splitYear, 100), // Every 100 years for ancient
          ...d3.range(splitYear, maxYear + 1, 10) // Every 10 years for modern
        ])
        .tickFormat(d => d < 0 ? `${-d} BC` : d)
        .tickSize(-width);

      axisGroup.attr("transform", `translate(${width - 80}, 0)`)
        .call(yAxis)
        .call(g => g.select(".domain").remove()) // Remove the vertical line
        .call(g => g.selectAll(".tick line")
          .attr("stroke-opacity", 0.1) // Faint grid lines
          .attr("stroke-dasharray", "2,2")); // Dashed grid lines

      // Lock Y positions
      authors.forEach(d => {
        d.fy = yScale(d.year); // Strictly lock Y
        d.y = d.fy; // Start at correct position
      });

      simulation = d3.forceSimulation(authors)
        //.force("y", d3.forceY(d => yScale(d.year)).strength(3)) // Removed: Y is locked
        .force("x", d3.forceX(width / 2).strength(0.2)) // Center horizontally
        .force("collide", d3.forceCollide(d => d.r + 5).iterations(2))
        .on("tick", ticked);

      function ticked() {
        // Render Links
        linkGroup.selectAll("line")
          .data(graphData.links)
          .join("line")
          .attr("class", "link")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        // Render Authors
        const authorSel = nodeGroup.selectAll(".author-group")
          .data(authors, d => d.id)
          .join(
            enter => {
              const g = enter.append("g")
                .attr("class", "author-group")
                .on("mouseenter", (e, d) => highlight(d))
                .on("mouseleave", () => resetHighlight())
                .on("click", (e, d) => {
                  e.stopPropagation();

                  // Toggle selection
                  if (selectedNode && selectedNode.id === d.id) {
                    selectedNode = null;
                    resetHighlight();
                  } else {
                    selectedNode = d; // Freeze selection
                    highlight(d);
                  }
                });

              g.append("circle")
                .attr("class", "author-circle")
                .attr("r", d => d.r);

              // Render Books inside
              g.each(function (d) {
                const group = d3.select(this);
                if (d.books) {
                  group.selectAll(".book-circle")
                    .data(d.books)
                    .join("circle")
                    .attr("class", "book-circle")
                    .attr("r", b => b.r)
                    .attr("cx", b => b.x)
                    .attr("cy", b => b.y)
                    .attr("fill", b => b.data.isSource ? "var(--book-source)" : "var(--book-cited)")
                    .on("mouseenter", (e, b) => {
                      // Show book title on hover
                      showTooltip(e, b.data.title);
                    })
                    .on("mouseleave", hideTooltip)
                    .on("click", (e, b) => {
                      e.stopPropagation();
                      showPanel(b.data);
                    });
                }
              });

              // Label (Author Name) - Hidden by default via CSS
              g.append("text")
                .attr("class", "label")
                .attr("y", d => -d.r - 10)
                .text(d => d.name);

              return g;
            }
          )
          .attr("transform", d => `translate(${d.x},${d.y})`);
      }
    }

    // Tooltip
    const tooltip = d3.select("body").append("div")
      .style("position", "absolute")
      .style("background", "rgba(0,0,0,0.8)")
      .style("padding", "4px 8px")
      .style("border-radius", "4px")
      .style("pointer-events", "none")
      .style("font-size", "12px")
      .style("display", "none")
      .style("z-index", "100");

    function showTooltip(e, text) {
      tooltip.style("display", "block")
        .text(text)
        .style("left", (e.pageX + 10) + "px")
        .style("top", (e.pageY - 10) + "px");
    }
    function hideTooltip() { tooltip.style("display", "none"); }

    function highlight(d) {
      // If a node is selected and it's not this one, ignore hover
      if (selectedNode && selectedNode.id !== d.id) return;

      // Dim all
      d3.selectAll(".author-group").classed("dimmed", true).classed("highlight", false);
      d3.selectAll(".label").classed("visible", false);
      d3.selectAll(".link").classed("dimmed", true).classed("highlight", false);

      // Highlight selected node
      const sel = d3.selectAll(".author-group").filter(n => n.id === d.id);
      sel.classed("dimmed", false).classed("highlight", true);
      sel.select(".label").classed("visible", true);

      // Find connected neighbors
      const connectedIds = new Set();
      connectedIds.add(d.id);

      // Highlight connected links and collect neighbors
      d3.selectAll(".link")
        .filter(l => {
          if (l.source.id === d.id) {
            connectedIds.add(l.target.id);
            return true;
          }
          if (l.target.id === d.id) {
            connectedIds.add(l.source.id);
            return true;
          }
          return false;
        })
        .classed("dimmed", false)
        .classed("highlight", true)
        .raise(); // Bring to front

      // Highlight connected neighbors
      d3.selectAll(".author-group")
        .filter(n => connectedIds.has(n.id))
        .classed("dimmed", false)
        .classed("highlight", true)
        .select(".label").classed("visible", true);
    }

    function resetHighlight() {
      // If a node is selected, don't reset
      if (selectedNode) return;

      d3.selectAll(".author-group").classed("dimmed", false).classed("highlight", false);
      d3.selectAll(".label").classed("visible", false);
      d3.selectAll(".link").classed("dimmed", false).classed("highlight", false);
    }

    function showPanel(book) {
      const panel = document.getElementById("info-panel");
      document.getElementById("panel-title").textContent = book.title;
      const content = document.getElementById("panel-content");

      const meta = book.meta || {};
      const authors = meta.authors ? (Array.isArray(meta.authors) ? meta.authors.join(", ") : meta.authors) : "Unknown Author";
      const rating = meta.average_rating ? `★ ${meta.average_rating}` : "";
      const pages = meta.num_pages ? `${meta.num_pages} pages` : "";
      const publisher = meta.publisher ? meta.publisher : "";
      const link = meta.link || meta.url;

      let metaHtml = `<div style="margin-bottom:12px; color:#888; font-size:13px;">${book.year || "Unknown Year"} • ${authors}</div>`;

      if (rating || pages || publisher) {
        metaHtml += `<div style="display:flex; gap:10px; margin-bottom:12px; font-size:12px; color:var(--text-muted);">`;
        if (rating) metaHtml += `<span>${rating}</span>`;
        if (pages) metaHtml += `<span>${pages}</span>`;
        if (publisher) metaHtml += `<span>${publisher}</span>`;
        metaHtml += `</div>`;
      }

      metaHtml += `<div style="line-height:1.5; margin-bottom:16px;">${meta.description || "No description available."}</div>`;

      if (link) {
        metaHtml += `<a href="${link}" target="_blank" style="display:inline-block; padding:8px 16px; background:rgba(255,255,255,0.1); color:#fff; text-decoration:none; border-radius:4px; font-size:12px; transition:background 0.2s;">View on Goodreads ↗</a>`;
      }

      content.innerHTML = metaHtml;
      panel.classList.add("visible");
    }

    document.getElementById("panel-close").onclick = () => {
      document.getElementById("info-panel").classList.remove("visible");
    };

    loadData();
  </script>
</body>

</html>