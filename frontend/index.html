<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>BookGraph Explorer</title>
  <style>
    :root {
      --bg: #050505;
      --panel: rgba(20, 20, 20, 0.9);
      --text: #ededed;
      --text-muted: #888;
      --accent: #00f2ff;

      /* Node Colors */
      --book-source: #ff4444;
      --book-cited: #4444ff;
      --author-fill: rgba(255, 255, 255, 0.05);
      --author-stroke: rgba(255, 255, 255, 0.2);

      --edge: #404040;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Outfit", "Inter", sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow-y: auto;
      /* Allow scrolling */
      overflow-x: hidden;
      touch-action: pan-y;
      /* Enforce vertical scrolling */
    }

    header {
      position: fixed;
      /* Fixed header */
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 24px;
      background: linear-gradient(180deg, rgba(5, 5, 5, 0.95), rgba(5, 5, 5, 0));
      display: flex;
      justify-content: space-between;
      z-index: 10;
      pointer-events: none;
    }

    header>* {
      pointer-events: auto;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      background: linear-gradient(90deg, #fff, #94a3b8);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header-content {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .cover-image {
      height: 120px;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.2s;
    }

    .cover-image:hover {
      transform: scale(1.5) translateY(20px);
      z-index: 100;
    }

    .header-text {
      display: flex;
      flex-direction: column;
    }

    .header-subtitle {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    #controls {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    /* Loading Indicator */
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: var(--text-muted);
      z-index: 100;
    }

    /* SVG Container */
    svg {
      display: block;
      width: 100%;
      min-height: 100vh;
    }

    /* Timeline Axis */
    .tick text {
      fill: var(--text-muted);
      font-size: 11px;
    }

    .tick line {
      stroke: var(--text-muted);
    }

    /* Links */
    .link {
      stroke: var(--edge);
      stroke-width: 1;
      stroke-opacity: 0.6;
    }

    .link.highlight {
      stroke: var(--accent);
      stroke-width: 2;
      stroke-opacity: 1;
    }

    .link.dimmed {
      stroke-opacity: 0.1;
    }

    /* Author Nodes */
    .author-circle {
      fill: var(--author-fill);
      stroke: var(--author-stroke);
      stroke-width: 1;
      cursor: pointer;
      transition: stroke 0.2s;
    }

    .author-group.highlight .author-circle {
      stroke: var(--accent);
      stroke-width: 2;
    }

    .author-group.dimmed .author-circle {
      opacity: 0.3;
    }

    /* Book Circles */
    .book-circle {
      cursor: pointer;
      transition: transform 0.2s;
    }

    .book-circle:hover {
      transform: scale(1.2);
    }

    /* Labels */
    .label {
      font-size: 11px;
      fill: var(--text);
      text-anchor: middle;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .label.visible {
      opacity: 1;
    }

    /* Search Box */
    .search-box {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 8px 16px;
      color: var(--text);
      font-size: 14px;
      outline: none;
      width: 200px;
    }

    .search-box:focus {
      border-color: var(--accent);
    }

    /* Info Panel */
    #info-panel {
      position: fixed;
      right: -400px;
      top: 0;
      width: 400px;
      height: 100vh;
      background: var(--panel);
      padding: 24px;
      overflow-y: auto;
      transition: right 0.3s ease;
      z-index: 20;
      border-left: 1px solid rgba(255, 255, 255, 0.1);
    }

    #info-panel.visible {
      right: 0;
    }

    #panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
    }

    #panel-title {
      font-size: 20px;
      font-weight: 600;
      margin: 0;
      flex: 1;
    }

    #panel-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    #panel-close:hover {
      color: var(--text);
    }

    #panel-content {
      font-size: 14px;
      line-height: 1.6;
    }

    /* Hero Section */
    #hero {
      padding: 100px 24px 40px;
      max-width: 800px;
      margin: 0 auto;
      text-align: center;
    }

    #hero h2 {
      font-size: 28px;
      font-weight: 600;
      margin: 0 0 16px;
      background: linear-gradient(90deg, #fff, #94a3b8);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #hero p {
      color: var(--text-muted);
      font-size: 15px;
      line-height: 1.6;
      margin: 0;
    }

    /* Control Labels */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }

    .control-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    /* Search Results Indicator */
    #search-results {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      font-size: 11px;
      color: var(--accent);
      white-space: nowrap;
    }

    /* Search Match Highlight */
    .author-group.search-match .author-circle {
      stroke: var(--accent);
      stroke-width: 2;
    }

    /* Hide hero when graph is loaded */
    #hero.hidden {
      display: none;
    }
  </style>
</head>

<body>
  <header>
    <div class="header-content">
      <img id="header-cover" class="cover-image" src="" style="display:none;" />
      <div class="header-text">
        <h1>BookGraph</h1>
        <div class="header-subtitle" id="header-subtitle">Exploring Citation Networks</div>
      </div>
    </div>

    <div id="controls">
      <div class="control-group">
        <span class="control-label">Library</span>
        <select id="dataset-select" class="search-box" style="width: auto; cursor: pointer;">
          <option value="" disabled selected>Select a library...</option>
        </select>
      </div>
      <div class="control-group">
        <span class="control-label">Search authors & books</span>
        <input type="text" class="search-box" placeholder="Type to search..." id="search">
        <span id="search-results"></span>
      </div>
    </div>
  </header>

  <div id="hero">
    <h2>Visualizing Literary Citation Networks</h2>
    <p>Explore how authors reference each other across time. Each circle represents an author, containing their books.
       Red circles are source texts being analyzed; blue circles are cited works.
       The vertical axis represents time, from ancient texts at the bottom to modern works at the top.
       Select a library above to begin exploring.</p>
  </div>

  <div id="loading">Loading...</div>

  <svg id="graph-svg">
    <g id="axis-group"></g>
    <g id="link-group"></g>
    <g id="node-group"></g>
  </svg>

  <div id="info-panel">
    <div id="panel-header">
      <h2 id="panel-title"></h2>
      <button id="panel-close">&times;</button>
    </div>
    <div id="panel-content"></div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Global variables
    let graphData = { authors: [], links: [] };
    let simulation = null;
    let selectedNode = null;

    const width = window.innerWidth;
    let height = window.innerHeight;

    const svg = d3.select("#graph-svg").attr("width", width).attr("height", height);
    const axisGroup = d3.select("#axis-group");
    const linkGroup = d3.select("#link-group");
    const nodeGroup = d3.select("#node-group");

    async function loadDataset(dataDir) {
      // Hide hero section when loading a dataset
      document.getElementById("hero").classList.add("hidden");
      document.getElementById("loading").style.display = "block";
      document.getElementById("loading").textContent = "Loading " + dataDir + "...";

      // Clear graph and search
      graphData = { authors: [], links: [] };
      if (simulation) simulation.stop();
      document.getElementById("search").value = "";
      document.getElementById("search-results").textContent = "";
      selectedNode = null;

      // Clear axis, links, and nodes
      axisGroup.selectAll("*").remove();
      linkGroup.selectAll("*").remove();
      nodeGroup.selectAll("*").remove();

      // Reset Header
      const headerCov = document.getElementById("header-cover");
      headerCov.style.display = "none";
      headerCov.src = "";

      // Check for dataset config in select
      const select = document.getElementById("dataset-select");
      const selectedOption = select.options[select.selectedIndex];
      const covers = selectedOption ? JSON.parse(selectedOption.getAttribute("data-covers") || "null") : null;

      // Clear any existing partial covers
      let shelfContainer = document.getElementById("header-shelf");
      if (!shelfContainer) {
        shelfContainer = document.createElement("div");
        shelfContainer.id = "header-shelf";
        shelfContainer.style.display = "flex";
        shelfContainer.style.gap = "8px";
        // Insert before title text if possible, or just before cover
        headerCov.parentNode.insertBefore(shelfContainer, headerCov);
      }
      shelfContainer.innerHTML = "";

      if (covers && covers.length > 0) {
        // Multiple Covers (Shelf)
        headerCov.style.display = "none";
        covers.forEach(c => {
          const img = document.createElement("img");
          img.className = "cover-image";
          // Only show image if it loads successfully and has valid dimensions
          img.onload = function() {
            if (this.naturalWidth > 50 && this.naturalHeight > 50) {
              this.style.display = "block";
            } else {
              this.remove(); // Remove tiny/placeholder images
            }
          };
          img.onerror = function() {
            this.remove(); // Remove broken images
          };
          img.style.display = "none"; // Hidden until validated
          img.src = `${dataDir}/${c}`;
          shelfContainer.appendChild(img);
        });
      } else {
        // Single Cover
        const coverPath = `${dataDir}/cover.jpg`;
        const img = new Image();
        img.onload = () => {
          headerCov.src = coverPath;
          headerCov.style.display = "block";
        };
        img.src = coverPath;
      }

      try {
        const [manifest] = await Promise.all([
          fetch(`${dataDir}/manifest.json`).then(r => r.json())
        ]);

        const files = [];
        const batchSize = 3;

        for (let i = 0; i < manifest.length; i += batchSize) {
          const batch = manifest.slice(i, i + batchSize);
          const results = await Promise.all(batch.map(f => fetch(`${dataDir}/${f}`).then(r => r.json())));
          files.push(...results);
        }
        processData(files);

        document.getElementById("loading").style.display = "none";
      } catch (e) {
        console.error(e);
        document.getElementById("loading").textContent = "Error loading data: " + e.message;
      }
    }

    function parseYear(dateStr) {
      if (!dateStr) return null;
      if (typeof dateStr === 'number') return dateStr;
      if (dateStr.toString().includes("BC")) return -parseInt(dateStr.replace(/\D/g, ''));
      const d = new Date(dateStr);
      return !isNaN(d.getFullYear()) ? d.getFullYear() : null;
    }

    function getBookYear(meta) {
      // Priority 1: Enriched Original Year (from pipeline)
      if (meta.original_year !== undefined && meta.original_year !== null) return meta.original_year;

      // Priority 2: Goodreads Pub Year
      if (meta.publication_year) return meta.publication_year;

      return null;
    }

    function normalizeAuthor(name) {
      if (!name) return "Unknown";
      let n = name.toString().trim();

      if (n.includes(",")) {
        const parts = n.split(",", 2);
        if (parts.length === 2) n = `${parts[1].trim()} ${parts[0].trim()}`;
      }
      return n.replace(/\s+/g, " ");
    }

    function processData(records) {
      const authorMap = new Map(); // name -> { name, books: [], year, meta: {} }
      const bookMap = new Map(); // id -> bookNode

      // 1. Collect all books and assign to authors
      records.forEach(rec => {
        // Source Book
        const src = rec.source;
        const srcAuth = normalizeAuthor(Array.isArray(src.authors) ? src.authors[0] : src.authors);
        const srcYear = getBookYear(src);

        if (!authorMap.has(srcAuth)) authorMap.set(srcAuth, {
          name: srcAuth, books: [], isSource: true, meta: {},
          commentaries: []
        });
        const srcAuthorNode = authorMap.get(srcAuth);

        // Check if source has meta (rarely populated in current pipeline but good for future)
        if (src.author_meta) srcAuthorNode.meta = src.author_meta;

        const srcBook = {
          id: `book:${src.goodreads_id}`,
          title: src.title,
          year: srcYear,
          isSource: true,
          meta: src
        };
        srcAuthorNode.books.push(srcBook);
        bookMap.set(srcBook.id, srcBook);

        // Cited Books
        (rec.citations || []).forEach(cit => {
          const match = cit.goodreads_match || {};
          const wiki = cit.wikipedia_match || {};

          // Harvest author metadata if available from enrichment
          const authorMeta = match.author_meta || {};

          // If it's a book citation
          if (cit.edge && cit.edge.target_book_id) {
            const citedAuth = normalizeAuthor(match.authors && match.authors.length > 0 ? match.authors[0] : "Unknown");
            const citedYear = getBookYear(match);

            if (!authorMap.has(citedAuth)) authorMap.set(citedAuth, { name: citedAuth, books: [], meta: {}, commentaries: [] });
            const citedAuthorNode = authorMap.get(citedAuth);

            // Merge meta if found
            if (Object.keys(authorMeta).length > 0) citedAuthorNode.meta = authorMeta;

            const citedBook = {
              id: `book:${cit.edge.target_book_id}`,
              title: match.title || "Unknown",
              year: citedYear,
              isSource: false,
              meta: match,
              commentaries: cit.raw.commentaries || []
            };

            // Avoid duplicates within author
            if (!citedAuthorNode.books.find(b => b.id === citedBook.id)) {
              citedAuthorNode.books.push(citedBook);
              bookMap.set(citedBook.id, citedBook);
            }
          }
          else if (cit.edge && cit.edge.target_author_ids) {
            const name = wiki.title || (match.authors && match.authors.length > 0 ? match.authors[0] : match.name) || "Unknown";
            const normName = normalizeAuthor(name);
            if (!authorMap.has(normName)) authorMap.set(normName, { name: normName, books: [], meta: {}, commentaries: [] });

            const authNode = authorMap.get(normName);
            // Merge meta
            if (Object.keys(authorMeta).length > 0) authNode.meta = authorMeta;

            // Accumulate commentaries
            if (cit.raw.commentaries) {
              if (!authNode.commentaries) authNode.commentaries = [];
              authNode.commentaries.push(...cit.raw.commentaries);
            }
          }
        });
      });

      // 2. Calculate Author Positions & Pack Books
      const authors = Array.from(authorMap.values()).map(auth => {
        // Calculate Year
        let year = null;
        const meta = auth.meta || {};

        // Priority 1: Author Metadata (Birth/Death) enriched from pipeline
        if (meta.birth_year) {
          // Use midpoint of life, or birth + 30 if death unknown (active years)
          const endYear = meta.death_year || (meta.birth_year + 60);
          year = (meta.birth_year + endYear) / 2;
        }

        // Priority 2: Mean of Book Years (Fallback)
        if (year === null) {
          const validBookYears = auth.books.map(b => b.year).filter(y => y !== null);
          if (validBookYears.length > 0) {
            year = validBookYears.reduce((a, b) => a + b, 0) / validBookYears.length;
          }
        }

        // Pack Books
        // We create a hierarchy: Root -> Books
        const root = { children: auth.books.map(b => ({ ...b, value: 1 })) };
        const pack = d3.pack().padding(2);
        // Estimate radius based on book count to avoid huge empty circles
        // But d3.pack needs a size. We can run it with an arbitrary size and then scale?
        // Better: d3.packSiblings (if we just had circles) or d3.packEnclose.
        // Let's use d3.pack on a hierarchy.

        const hierarchy = d3.hierarchy(root).sum(d => d.value || 1);
        // Radius of book = 5 (source) or 3 (cited)
        hierarchy.children?.forEach(c => {
          c.r = c.data.isSource ? 12 : 6;
        });

        // We need to pack them. d3.pack() expects a size.
        // Instead, let's use d3.packSiblings which packs circles tightly.
        const circles = (hierarchy.children || []).map(c => ({ r: c.r, data: c.data }));
        d3.packSiblings(circles);

        // Enclose them to get author radius
        const enclosure = d3.packEnclose(circles);
        const r = enclosure ? enclosure.r + 5 : (auth.isSource ? 10 : 5); // Padding

        return {
          commentaries: [...new Set(auth.commentaries)],
          id: `author:${auth.name}`,
          name: auth.name,
          year: year,
          r: r,
          books: circles, // {x, y, r, data} relative to center (0,0)
          x: width / 2, // Initial pos
          y: height / 2,
          isSource: auth.isSource || false,
          meta: auth.meta || {}
        };
      });

      // Handle authors with no year data
      // Source authors without dates default to 2000, cited authors to 1950
      authors.forEach(a => {
        if (a.year === null) {
          a.year = a.isSource ? 2000 : 1950;
        }
      });
      const validAuthors = authors;

      // 3. Links (Author to Author)
      const authorNodeMap = new Map(validAuthors.map(a => [a.name, a]));
      const linkSet = new Set();
      const links = [];

      records.forEach(rec => {
        const src = rec.source;
        const srcName = normalizeAuthor(Array.isArray(src.authors) ? src.authors[0] : src.authors);
        const srcNode = authorNodeMap.get(srcName);

        if (!srcNode) return;

        (rec.citations || []).forEach(cit => {
          let targetName = null;
          const match = cit.goodreads_match || {};
          const wiki = cit.wikipedia_match || {};

          if (cit.edge && cit.edge.target_book_id) {
            targetName = normalizeAuthor(match.authors && match.authors.length > 0 ? match.authors[0] : "Unknown");
          } else if (cit.edge && cit.edge.target_author_ids) {
            targetName = normalizeAuthor(wiki.title || (match.authors && match.authors.length > 0 ? match.authors[0] : match.name) || "Unknown");
          }

          if (targetName) {
            const targetNode = authorNodeMap.get(targetName);
            if (targetNode && targetNode !== srcNode) {
              const key = `${srcName}|${targetName}`;
              if (!linkSet.has(key)) {
                linkSet.add(key);
                links.push({ source: srcNode, target: targetNode });
              }
            }
          }
        });
      });

      graphData.authors = validAuthors;
      graphData.links = links;
      initSimulation();
    }

    function initSimulation() {
      const authors = graphData.authors;

      // Y Scale: Ancient (Bottom) -> Modern (Top)
      // Y Scale: Ancient (Bottom) -> Modern (Top)
      const years = authors.map(a => a.year);
      const minYear = Math.min(...years);
      const maxYear = Math.max(...years);

      // Variable Resolution Configuration
      const splitYear = 1800; // Breakpoint between low and high density
      const lowRes = 0.3; // Pixels per year for Ancient/Pre-1800 (Balanced)
      const highRes = 8; // Pixels per year for Modern/Post-1800 (Balanced)

      // Calculate Distances
      const ancientSpan = Math.max(0, splitYear - minYear);
      const modernSpan = Math.max(0, maxYear - splitYear);

      const ancientHeight = ancientSpan * lowRes;
      const modernHeight = modernSpan * highRes;

      const totalHeight = ancientHeight + modernHeight + 400; // + Padding

      svg.attr("height", totalHeight);

      // Polylinear Scale
      // Domain: [Min, Split, Max]
      // Range: [Bottom, SplitPoint, Top]
      // Note: Y coords go Top(0) -> Bottom(Height).
      // So MinYear is at TotalHeight (minus padding), MaxYear is at Top (plus padding).

      const yBottom = totalHeight - 100;
      const ySplit = yBottom - ancientHeight;
      const yTop = ySplit - modernHeight; // Should be approx 300

      const yScale = d3.scaleLinear()
        .domain([minYear, splitYear, maxYear])
        .range([yBottom, ySplit, yTop]);

      // Axis
      const yAxis = d3.axisRight(yScale)
        .tickValues([
          ...d3.range(Math.ceil(minYear / 100) * 100, splitYear, 100), // Every 100 years for ancient
          ...d3.range(splitYear, maxYear + 1, 10) // Every 10 years for modern
        ])
        .tickFormat(d => d < 0 ? `${-d} BC` : d)
        .tickSize(-width);

      axisGroup
        .attr("transform", `translate(${width - 80}, 0)`)
        .call(yAxis)
        .call(g => g.select(".domain").remove()) // Remove the vertical line
        .call(g => g.selectAll(".tick line")
          .attr("stroke-opacity", 0.1) // Faint grid lines
          .attr("stroke-dasharray", "2,2")); // Dashed grid lines

      // Lock Y positions
      authors.forEach(d => {
        d.fy = yScale(d.year); // Strictly lock Y
        d.y = d.fy; // Start at correct position
      });

      simulation = d3.forceSimulation(authors)
        //.force("y", d3.forceY(d => yScale(d.year)).strength(3)) // Removed: Y is locked
        .force("x", d3.forceX(width / 2).strength(0.3)) // Stronger centering
        .force("collide", d3.forceCollide(d => d.r + 5).iterations(2))
        .on("tick", ticked);

      function ticked() {
        // Constrain to screen width
        authors.forEach(d => {
          d.x = Math.max(d.r + 10, Math.min(width - d.r - 10, d.x));
        });

        // Render Links
        linkGroup.selectAll("line")
          .data(graphData.links)
          .join("line")
          .attr("class", "link")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        // Render Authors
        const authorSel = nodeGroup.selectAll(".author-group")
          .data(authors, d => d.id)
          .join(
            enter => {
              const g = enter.append("g")
                .attr("class", "author-group")
                .on("mouseenter", (e, d) => highlight(d))
                .on("mouseleave", () => resetHighlight())
                .on("click", (e, d) => {
                  e.stopPropagation();

                  // Toggle selection
                  if (selectedNode && selectedNode.id === d.id) {
                    selectedNode = null;
                    resetHighlight();
                  } else {
                    selectedNode = d; // Freeze selection
                    highlight(d);
                    showPanel(d);
                  }
                });

              g.append("circle")
                .attr("class", "author-circle")
                .attr("r", d => d.r);

              // Render Books inside
              g.each(function (d) {
                const group = d3.select(this);
                if (d.books) {
                  group.selectAll(".book-circle")
                    .data(d.books)
                    .join("circle")
                    .attr("class", "book-circle")
                    .attr("r", b => b.r)
                    .attr("cx", b => b.x)
                    .attr("cy", b => b.y)
                    .attr("fill", b => b.data.isSource ? "var(--book-source)" : "var(--book-cited)")
                    .on("mouseenter", (e, b) => {
                      // Show book title on hover
                      showTooltip(e, b.data.title);
                    })
                    .on("mouseleave", hideTooltip)
                    .on("click", (e, b) => {
                      e.stopPropagation();
                      showPanel(b.data);
                    });
                }
              });

              // Label (Author Name) - Hidden by default via CSS
              g.append("text")
                .attr("class", "label")
                .attr("y", d => -d.r - 10)
                .text(d => d.name);

              return g;
            }
          )
          .attr("transform", d => `translate(${d.x},${d.y})`);
      }
    }

    // Tooltip
    const tooltip = d3.select("body").append("div")
      .style("position", "absolute")
      .style("background", "rgba(0,0,0,0.8)")
      .style("padding", "4px 8px")
      .style("border-radius", "4px")
      .style("pointer-events", "none")
      .style("font-size", "12px")
      .style("display", "none")
      .style("z-index", "100");

    function showTooltip(e, text) {
      tooltip.style("display", "block")
        .text(text)
        .style("left", (e.pageX + 10) + "px")
        .style("top", (e.pageY - 10) + "px");
    }
    function hideTooltip() { tooltip.style("display", "none"); }

    function highlight(d) {
      // If a node is selected and it's not this one, ignore hover
      if (selectedNode && selectedNode.id !== d.id) return;

      // Dim all
      d3.selectAll(".author-group").classed("dimmed", true).classed("highlight", false);
      d3.selectAll(".label").classed("visible", false);
      d3.selectAll(".link").classed("dimmed", true).classed("highlight", false);

      // Highlight selected node
      const sel = d3.selectAll(".author-group").filter(n => n.id === d.id);
      sel.classed("dimmed", false).classed("highlight", true);
      sel.select(".label").classed("visible", true);

      // Find connected neighbors
      const connectedIds = new Set();
      connectedIds.add(d.id);

      // Highlight connected links and collect neighbors
      // Highlight connected links and collect neighbors (OUTBOUND ONLY)
      d3.selectAll(".link")
        .filter(l => {
          if (l.source.id === d.id) {
            connectedIds.add(l.target.id);
            return true;
          }
          // Removed inbound check: if (l.target.id === d.id) ...
          return false;
        })
        .classed("dimmed", false)
        .classed("highlight", true)
        .raise(); // Bring to front

      // Highlight connected neighbors
      d3.selectAll(".author-group")
        .filter(n => connectedIds.has(n.id))
        .classed("dimmed", false)
        .classed("highlight", true)
        .select(".label").classed("visible", true);
    }

    function resetHighlight() {
      // If a node is selected, don't reset
      if (selectedNode) return;

      d3.selectAll(".author-group").classed("dimmed", false).classed("highlight", false);
      d3.selectAll(".label").classed("visible", false);
      d3.selectAll(".link").classed("dimmed", false).classed("highlight", false);
    }

    function showPanel(node) {
      const panel = document.getElementById("info-panel");
      // Handle both Book and Author nodes
      // Book: title, meta.authors, meta.link, etc.
      // Author: name, meta (birth_year, etc.), commentaries

      const isBook = node.id && node.id.startsWith("book:");
      const title = isBook ? node.title : node.name;
      document.getElementById("panel-title").textContent = title;

      const content = document.getElementById("panel-content");
      const meta = node.meta || {};

      let metaHtml = "";

      if (isBook) {
        const authors = meta.authors ? (Array.isArray(meta.authors) ? meta.authors.join(", ") : meta.authors) : "Unknown Author";
        metaHtml += `<div style="margin-bottom:12px; color:#888; font-size:13px;">${node.year || "Unknown Year"} • ${authors}</div>`;
      } else {
        // Author Metadata
        metaHtml += `<div style="margin-bottom:12px; color:#888; font-size:13px;">Author</div>`;
        if (meta.birth_year) {
          metaHtml += `<div style="margin-bottom:12px; color:#aaa; font-size:13px;">${meta.birth_year} – ${meta.death_year || "Present"}</div>`;
        }
      }

      if (meta.average_rating || meta.num_pages || meta.publisher) {
        metaHtml += `<div style="display:flex; gap:10px; margin-bottom:12px; font-size:12px; color:var(--text-muted);">`;
        if (meta.average_rating) metaHtml += `<span>★ ${meta.average_rating}</span>`;
        if (meta.num_pages) metaHtml += `<span>${meta.num_pages} pages</span>`;
        if (meta.publisher) metaHtml += `<span>${meta.publisher}</span>`;
        metaHtml += `</div>`;
      }

      if (meta.description) {
        metaHtml += `<div style="line-height:1.5; margin-bottom:16px;">${meta.description}</div>`;
      }

      // Commentaries (from node.commentaries or meta if stored there?)
      // We pass commentaries in node.commentaries for both Books and Authors now
      // (For books we attached it to the node in processData, for authors we did too)

      if (node.commentaries && node.commentaries.length > 0) {
        metaHtml += `<div style="margin-top:16px; padding-top:16px; border-top:1px solid rgba(255,255,255,0.1);">`;
        metaHtml += `<h4 style="margin:0 0 8px 0; font-size:14px; color:var(--accent);">Author Commentary</h4>`;
        node.commentaries.forEach(c => {
          metaHtml += `<div style="font-style:italic; font-size:13px; color:#ddd; margin-bottom:8px; padding-left:8px; border-left:2px solid var(--accent);">${c}</div>`;
        });
        metaHtml += `</div>`;
      }

      // Link
      const link = meta.link || meta.url;
      if (link) {
        metaHtml += `<a href="${link}" target="_blank" style="display:inline-block; padding:8px 16px; background:rgba(255,255,255,0.1); color:#fff; text-decoration:none; border-radius:4px; font-size:12px; transition:background 0.2s;">View on Web ↗</a>`;
      }

      content.innerHTML = metaHtml;
      panel.classList.add("visible");
    }

    document.getElementById("panel-close").onclick = () => {
      document.getElementById("info-panel").classList.remove("visible");
      selectedNode = null;
      resetHighlight();
    };

    // Click outside to deselect
    svg.on("click", () => {
      selectedNode = null;
      resetHighlight();
      document.getElementById("info-panel").classList.remove("visible");
    });

    // Search functionality with scroll to match
    let searchTimeout = null;
    document.getElementById("search").addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase().trim();
      const resultsEl = document.getElementById("search-results");

      // Clear previous timeout
      if (searchTimeout) clearTimeout(searchTimeout);

      if (!query) {
        // Reset all nodes when search is cleared
        d3.selectAll(".author-group").classed("dimmed", false).classed("search-match", false);
        d3.selectAll(".label").classed("visible", false);
        resultsEl.textContent = "";
        return;
      }

      // Debounce search
      searchTimeout = setTimeout(() => {
        const matches = [];

        d3.selectAll(".author-group").each(function(d) {
          const authorMatch = d.name.toLowerCase().includes(query);
          const bookMatch = d.books.some(b => b.data.title.toLowerCase().includes(query));
          const isMatch = authorMatch || bookMatch;

          d3.select(this).classed("dimmed", !isMatch);
          d3.select(this).classed("search-match", isMatch);
          d3.select(this).select(".label").classed("visible", isMatch);

          if (isMatch) {
            // Calculate match score (prefer exact/start matches)
            let score = 0;
            if (d.name.toLowerCase() === query) score = 100;
            else if (d.name.toLowerCase().startsWith(query)) score = 80;
            else if (authorMatch) score = 60;
            else score = 40; // book match

            matches.push({ node: d, element: this, score, authorMatch });
          }
        });

        // Sort by score and scroll to best match
        matches.sort((a, b) => b.score - a.score);

        if (matches.length > 0) {
          resultsEl.textContent = `${matches.length} match${matches.length > 1 ? 'es' : ''} found`;

          // Scroll to the best match
          const best = matches[0];
          const y = best.node.y || best.node.fy;
          if (y !== undefined) {
            window.scrollTo({
              top: y - window.innerHeight / 3,
              behavior: 'smooth'
            });
          }

          // Highlight the best match
          selectedNode = best.node;
          highlight(best.node);
        } else {
          resultsEl.textContent = "No matches";
        }
      }, 200);
    });

    // Enter key scrolls to next match
    document.getElementById("search").addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.target.value = "";
        e.target.dispatchEvent(new Event("input"));
      }
    });

    async function init() {
      try {
        const datasets = await fetch("datasets.json").then(r => r.json());
        const select = document.getElementById("dataset-select");

        datasets.forEach(ds => {
          const opt = document.createElement("option");
          opt.value = ds.path;
          opt.textContent = ds.name;
          if (ds.covers) {
            opt.setAttribute("data-covers", JSON.stringify(ds.covers));
          }
          select.appendChild(opt);
        });

        select.addEventListener("change", () => {
          if (select.value) {
            loadDataset(select.value);
          }
        });

        // Auto-load first dataset
        if (datasets.length > 0) {
          select.value = datasets[0].path;
          loadDataset(datasets[0].path);
        }
      } catch (e) {
        console.error("Failed to load datasets:", e);
        document.getElementById("loading").textContent = "Error loading datasets.json";
      }
    }

    init();
  </script>
</body>

</html>